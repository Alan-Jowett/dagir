/**
 * @file test_ro_dag_view.cpp
 * @brief Unit tests for DagIR ReadOnlyDagView concept and related utilities.
 *
 * @details
 * This test verifies:
 *  - A mock adapter correctly models ::dagir::ReadOnlyDagView.
 *  - Bounds checking prevents out-of-range access for children() and roots().
 *  - Concepts and helper utilities behave as expected.
 *
 * @copyright
 * Â© DagIR Contributors. All rights reserved.
 * SPDX-License-Identifier: MIT
 */

#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
#include <dagir/ro_dag_view.hpp>
#include <vector>
#include <cstdint>

/**
 * @brief Mock handle type for testing NodeHandle concept.
 */
struct MockHandle {
    std::uint64_t id{};
    constexpr std::uint64_t stable_key() const noexcept { return id; }
    constexpr const void* debug_address() const noexcept { return this; }
    friend constexpr bool operator==(MockHandle a, MockHandle b) noexcept { return a.id == b.id; }
    friend constexpr bool operator!=(MockHandle a, MockHandle b) noexcept { return !(a == b); }
};

/**
 * @brief Mock edge type for testing EdgeRef concept.
 */
struct MockEdge {
    MockHandle child{};
    constexpr MockHandle target() const noexcept { return child; }
};

/**
 * @brief Mock DAG view that satisfies ReadOnlyDagView.
 *
 * Adds bounds checking for children() and roots().
 */
class MockDagView {
public:
    using handle = MockHandle;

    explicit MockDagView(std::vector<handle> roots,
                         std::vector<std::vector<handle>> adjacency)
        : roots_(std::move(roots)), adj_(std::move(adjacency)) {}

    /// @brief Returns range of children for a given handle, empty if out-of-bounds.
    auto children(handle h) const {
        const size_t idx = static_cast<size_t>(h.id);
        if (idx >= adj_.size()) {
            struct EmptyRange {
                struct It {
                    bool operator==(const It&) const { return true; }
                    MockEdge operator*() const { return {}; }
                    It& operator++() { return *this; }
                };
                It begin() const { return {}; }
                It end() const { return {}; }
            };
            return EmptyRange{};
        }

        struct Range {
            const std::vector<handle>* vec{};
            struct It {
                const handle* p{};
                const handle* e{};
                MockEdge operator*() const { return MockEdge{ *p }; }
                It& operator++() { ++p; return *this; }
                bool operator==(const It& o) const { return p == o.p; }
            };
            It begin() const { return { vec->data(), vec->data() + vec->size() }; }
            It end() const { return { vec->data() + vec->size(), vec->data() + vec->size() }; }
        };
        return Range{ &adj_[idx] };
    }

    /// @brief Returns range of roots, empty if roots_ is empty.
    auto roots() const {
        if (roots_.empty()) {
            struct EmptyRange {
                struct It {
                    bool operator==(const It&) const { return true; }
                    const handle& operator*() const {
                        static handle dummy{};
                        return dummy;
                    }
                    It& operator++() { return *this; }
                };
                It begin() const { return {}; }
                It end() const { return {}; }
            };
            return EmptyRange{};
        }

        struct Range {
            const std::vector<handle>* vec{};
            struct It {
                const handle* p{};
                const handle* e{};
                const handle& operator*() const { return *p; }
                It& operator++() { ++p; return *this; }
                bool operator==(const It& o) const { return p == o.p; }
            };
            It begin() const { return { vec->data(), vec->data() + vec->size() }; }
            It end() const { return { vec->data() + vec->size(), vec->data() + vec->size() }; }
        };
        return Range{ &roots_ };
    }

private:
    std::vector<handle> roots_;
    std::vector<std::vector<handle>> adj_;
};

// -----------------------------
// Tests
// -----------------------------

TEST_CASE("MockHandle satisfies NodeHandle concept", "[concepts]") {
    STATIC_REQUIRE(dagir::NodeHandle<MockHandle>);
    MockHandle h{42};
    REQUIRE(h.stable_key() == 42);
    REQUIRE(h.debug_address() == &h);
}

TEST_CASE("MockEdge satisfies EdgeRef concept", "[concepts]") {
    STATIC_REQUIRE(dagir::EdgeRef<MockEdge, MockHandle>);
    MockHandle h{7};
    MockEdge e{h};
    REQUIRE(e.target().stable_key() == 7);
}

TEST_CASE("MockDagView satisfies ReadOnlyDagView concept", "[concepts]") {
    STATIC_REQUIRE(dagir::ReadOnlyDagView<MockDagView>);
    STATIC_REQUIRE(dagir::models_read_only_view<MockDagView>());

    MockHandle root{0}, child{1};
    MockDagView view({root}, {{child}, {}});

    auto roots = view.roots();
    REQUIRE((*roots.begin()).stable_key() == 0);

    auto children = view.children(root);
    REQUIRE((*children.begin()).target().stable_key() == 1);

    // Bounds check: invalid handle should yield empty range
    MockHandle invalid{99};
    auto emptyChildren = view.children(invalid);
    REQUIRE(emptyChildren.begin() == emptyChildren.end());
}

TEST_CASE("Empty roots returns empty range", "[bounds]") {
    MockDagView emptyView({}, {});
    auto emptyRoots = emptyView.roots();
    REQUIRE(emptyRoots.begin() == emptyRoots.end());
}

TEST_CASE("BasicEdge wrapper returns correct target", "[utility]") {
    dagir::BasicEdge<MockHandle> edge{ MockHandle{99} };
    REQUIRE(edge.target().stable_key() == 99);
}
